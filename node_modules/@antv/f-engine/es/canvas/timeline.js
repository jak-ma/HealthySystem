import { __extends } from "tslib";
/* animation timeline control */
import { Group } from '@antv/g-lite';
import Animator from './render/animator';
import EE from 'eventemitter3';
var Timeline = /** @class */function (_super) {
  __extends(Timeline, _super);
  function Timeline(props) {
    var _this = _super.call(this) || this;
    _this.animUnits = [];
    _this.frame = 0;
    _this.playState = 'play';
    _this.next = function () {
      var _a = _this,
        frame = _a.frame,
        playState = _a.playState,
        endFrame = _a.endFrame,
        speed = _a.speed;
      if (playState !== 'play') return;
      _this.frame = frame + 1;
      if (frame < endFrame) {
        _this.drawFrame();
        _this.animator.run();
        _this.setPlaybackRate(speed);
      } else {
        _this.emit('end');
        _this.playState = 'finish';
      }
    };
    var animUnits = props.animUnits,
      playState = props.playState,
      root = props.root,
      _a = props.speed,
      speed = _a === void 0 ? 1 : _a,
      time = props.time;
    _this.animator = new Animator();
    var rootShape = new Group();
    _this.animator.reset(rootShape);
    root.appendChild(rootShape);
    _this.animUnits = animUnits;
    _this.playState = playState;
    _this.endFrame = animUnits.length - 1;
    _this.speed = speed;
    _this.time = time;
    _this.totalDuration = animUnits.reduce(function (accumulator, current) {
      return accumulator + current.time;
    }, 0);
    return _this;
  }
  Timeline.prototype.start = function () {
    var _a = this,
      animator = _a.animator,
      frame = _a.frame,
      playState = _a.playState,
      endFrame = _a.endFrame,
      time = _a.time,
      speed = _a.speed;
    animator.on('end', this.next);
    if (frame < endFrame && playState === 'finish') {
      this.setFinishState();
      return;
    }
    this.drawFrame();
    this.animator.run();
    this.setPlayState(playState);
    time && this.goTo(time);
    this.setPlaybackRate(speed);
  };
  Timeline.prototype.drawFrame = function () {
    var _a = this,
      animator = _a.animator,
      animUnits = _a.animUnits,
      frame = _a.frame;
    var childAnimator = animUnits[frame].animators;
    animator.shape.removeChildren();
    childAnimator.map(function (d) {
      animator.shape.appendChild(d === null || d === void 0 ? void 0 : d.shape);
    });
    animator.children = childAnimator;
  };
  Timeline.prototype.setPlayState = function (state) {
    var animator = this.animator;
    switch (state) {
      case 'play':
        animator.play();
        break;
      case 'pause':
        animator.pause();
        break;
      case 'finish':
        animator.finish();
        break;
      default:
        break;
    }
  };
  Timeline.prototype.setPlaybackRate = function (speed) {
    var animator = this.animator;
    this.speed = speed;
    animator.setPlaybackRate(speed);
  };
  Timeline.prototype.getPlayState = function () {
    return this.playState;
  };
  Timeline.prototype.updateState = function (state) {
    // 播放状态不同
    if (state === 'finish') {
      this.setFinishState();
      return;
    }
    this.playState = state;
    this.setPlayState(state);
  };
  Timeline.prototype.clear = function () {
    this.animator = null;
    this.animUnits = [];
    this.playState = null;
    this.endFrame = null;
  };
  Timeline.prototype.goTo = function (time) {
    var _a = this,
      frame = _a.frame,
      animUnits = _a.animUnits,
      playState = _a.playState,
      totalDuration = _a.totalDuration;
    // 超出了总时长
    if (time > totalDuration && playState !== 'finish') {
      this.setFinishState();
      return;
    }
    var target;
    for (target = 0; target < animUnits.length; target++) {
      var cur = animUnits[target];
      if (time > cur.time) {
        time -= cur.time; // 计算剩余时间
      } else {
        break;
      }
    }
    if (frame !== target) {
      this.frame = target;
      this.drawFrame();
      // 结束当前动画
      this.setPlayState('finish');
      this.animator.run();
      this.setPlayState(playState);
    }
    this.animator.goTo(time);
  };
  Timeline.prototype.setFinishState = function () {
    var endFrame = this.endFrame;
    this.frame = endFrame;
    this.drawFrame();
    this.animator.run();
    this.setPlayState('finish');
    this.playState = 'finish';
    this.frame = endFrame + 1;
    this.animator.animations = [];
  };
  return Timeline;
}(EE);
export default Timeline;