import { __extends } from "tslib";
import Base from './base';
import { mat2d, vec2 } from 'gl-matrix';
import { vec2Zero, vec2AngleTo } from '../util/vector';
var Polar = /** @class */function (_super) {
  __extends(Polar, _super);
  function Polar() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = 'polar';
    _this.isPolar = true;
    return _this;
  }
  Polar.prototype.update = function (option) {
    _super.prototype.update.call(this, option);
    if (!this.option) {
      this.option = option;
    }
    var _a = this.option,
      _b = _a.radius,
      radiusRatio = _b === void 0 ? 1 : _b,
      _c = _a.innerRadius,
      innerRadiusRatio = _c === void 0 ? 0 : _c;
    var _d = this,
      width = _d.width,
      height = _d.height,
      _e = _d.startAngle,
      startAngle = _e === void 0 ? -Math.PI / 2 : _e,
      _f = _d.endAngle,
      endAngle = _f === void 0 ? Math.PI * 3 / 2 : _f;
    // 半径取宽高的最小值
    var radius = radiusRatio * (Math.min(width, height) / 2);
    // 极坐标下 x 表示弧度， y 代表 半径
    var x = [startAngle, endAngle];
    var y = [innerRadiusRatio * radius, radius];
    this.x = x;
    this.y = y;
    this.startAngle = startAngle;
    this.endAngle = endAngle;
    this.radius = radius;
    this.innnerRadius = innerRadiusRatio * radius;
    return this;
  };
  Polar.prototype.isCyclic = function () {
    var _a = this,
      startAngle = _a.startAngle,
      endAngle = _a.endAngle;
    if (endAngle - startAngle < Math.PI * 2) {
      return false;
    }
    return true;
  };
  Polar.prototype.convertPoint = function (point) {
    var _a = this,
      center = _a.center,
      transposed = _a.transposed,
      x = _a.x,
      y = _a.y;
    var xDim = transposed ? 'y' : 'x';
    var yDim = transposed ? 'x' : 'y';
    var xStart = x[0],
      xEnd = x[1];
    var yStart = y[0],
      yEnd = y[1];
    var angle = xStart + (xEnd - xStart) * point[xDim];
    var radius = yStart + (yEnd - yStart) * point[yDim];
    return {
      x: center.x + Math.cos(angle) * radius,
      y: center.y + Math.sin(angle) * radius
    };
  };
  Polar.prototype.invertPoint = function (point) {
    var _a = this,
      center = _a.center,
      transposed = _a.transposed,
      x = _a.x,
      y = _a.y;
    var xDim = transposed ? 'y' : 'x';
    var yDim = transposed ? 'x' : 'y';
    var xStart = x[0],
      xEnd = x[1];
    var yStart = y[0],
      yEnd = y[1];
    var m = [1, 0, 0, 1, 0, 0];
    mat2d.rotate(m, m, xStart);
    var startV = [1, 0];
    vec2.transformMat2d(startV, startV, m);
    startV = [startV[0], startV[1]];
    var pointV = [point.x - center.x, point.y - center.y];
    if (vec2Zero(pointV)) {
      return {
        x: 0,
        y: 0
      };
    }
    var theta = vec2AngleTo(startV, pointV, xEnd < xStart);
    if (Math.abs(theta - Math.PI * 2) < 0.001) {
      theta = 0;
    }
    var l = vec2.length(pointV);
    var percentX = theta / (xEnd - xStart);
    percentX = xEnd - xStart > 0 ? percentX : -percentX;
    var percentY = (l - yStart) / (yEnd - yStart);
    var rst = {};
    rst[xDim] = percentX;
    rst[yDim] = percentY;
    return rst;
  };
  return Polar;
}(Base);
export default Polar;