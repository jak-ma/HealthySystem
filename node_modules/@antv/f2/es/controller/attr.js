import { __assign } from "tslib";
import { each, isString, isNil, isFunction, isNumber, isArray, upperFirst } from '@antv/util';
import * as Attrs from '../attr';
import { isEqual } from '@antv/f-engine';
var Identity = Attrs.Identity,
  Linear = Attrs.Linear,
  Category = Attrs.Category;
// 需要映射的属性名
export var ATTRS = ['x', 'y', 'color', 'size', 'shape'];
// 分组处理的属性
var GROUP_ATTRS = ['color', 'size', 'shape'];
function cloneScale(scale, scaleConfig) {
  // @ts-ignore
  return new scale.constructor(__assign(__assign({}, scale.__cfg__), scaleConfig));
}
var AttrController = /** @class */function () {
  function AttrController(scaleController, attrsRange) {
    this.scaleController = scaleController;
    this.attrsRange = attrsRange;
    this.options = {};
    this.attrs = {};
  }
  AttrController.prototype.parseOption = function (option, attrName) {
    if (!option) {
      return {
        type: 'identity'
      };
    }
    if (isString(option)) {
      return {
        field: option,
        type: 'category'
      };
    }
    if (isNumber(option)) {
      if (attrName === 'size') {
        return {
          type: 'identity',
          field: option
        };
      }
    }
    if (isArray(option)) {
      return {
        field: option[0],
        range: option[1]
      };
    }
    return option;
  };
  AttrController.prototype.getAttrOptions = function (props, justifyContentCenter) {
    var _this = this;
    if (!props.x || !props.y) {
      throw new Error('x, y are required !');
    }
    var options = {};
    var ranges = this.attrsRange;
    ATTRS.forEach(function (attrName) {
      if (!props[attrName]) return;
      var option = _this.parseOption(props[attrName], attrName);
      if (!option.range) {
        option.range = ranges[attrName];
      }
      options[attrName] = option;
    });
    // @ts-ignore
    var x = options.x,
      y = options.y;
    x.justifyContent = justifyContentCenter;
    // x, y 都是固定Linear 映射
    x.type = Linear;
    y.type = Linear;
    return options;
  };
  AttrController.prototype.getDefaultAttrValues = function () {
    var _a = this.attrsRange,
      color = _a.color,
      shape = _a.shape;
    return {
      color: color[0],
      shape: shape && shape[0]
    };
  };
  AttrController.prototype.getGroupScales = function () {
    var attrs = this.attrs;
    var scales = [];
    each(GROUP_ATTRS, function (attrName) {
      var attr = attrs[attrName];
      if (!attr) {
        return;
      }
      var scale = attr.scale;
      if (scale && scale.isCategory && scales.indexOf(scale) === -1) {
        scales.push(scale);
      }
    });
    return scales;
  };
  AttrController.prototype.createAttr = function (option) {
    var type = option.type,
      field = option.field,
      scaleConfig = option.scale;
    if (isNil(field) || type === Identity) {
      return new Identity(option);
    }
    var scale = this.scaleController.getScale(field);
    var attrOption = __assign(__assign({}, option), {
      data: this.scaleController.getData(),
      // scaleConfig 只在属性映射中生效
      scale: scaleConfig ? cloneScale(scale, scaleConfig) : scale
    });
    // identity
    if (scale && scale.type === 'identity') {
      return new Identity(attrOption);
    }
    // Attr的默认类型和scale类型保持一致
    var AttrConstructor = scale.isLinear ? Linear : Category;
    // custom Attr Constructor
    if (isFunction(type)) {
      AttrConstructor = type;
    }
    if (isString(type) && Attrs[upperFirst(type)]) {
      AttrConstructor = Attrs[upperFirst(type)];
    }
    return new AttrConstructor(attrOption);
  };
  AttrController.prototype.create = function (options) {
    this.update(options);
  };
  AttrController.prototype.update = function (nextOptions) {
    var _a = this,
      scaleController = _a.scaleController,
      lastOptions = _a.options,
      lastAttrs = _a.attrs;
    var nextAttrs = {};
    each(nextOptions, function (nextOption, attrName) {
      var lastOption = lastOptions[attrName];
      if (isEqual(nextOption, lastOption)) {
        nextAttrs[attrName] = lastAttrs[attrName];
      }
      var field = nextOption.field,
        justifyContent = nextOption.justifyContent;
      if (field) {
        scaleController.setScale(field, {
          justifyContent: justifyContent
        });
      }
    });
    this.options = nextOptions;
    this.attrs = nextAttrs;
  };
  AttrController.prototype.getAttr = function (attrName) {
    var _a = this,
      attrs = _a.attrs,
      options = _a.options;
    var attr = attrs[attrName];
    if (attr) {
      return attr;
    }
    var option = options[attrName];
    if (!option) {
      return null;
    }
    var newAttr = this.createAttr(option);
    attrs[attrName] = newAttr;
    return newAttr;
  };
  AttrController.prototype.getAttrs = function () {
    var _this = this;
    var _a = this,
      options = _a.options,
      attrs = _a.attrs;
    each(options, function (option, attrName) {
      _this.getAttr(attrName);
    });
    return attrs;
  };
  AttrController.prototype.isGroupAttr = function (attrName) {
    return GROUP_ATTRS.indexOf(attrName) !== -1;
  };
  AttrController.prototype.getAttrsByLinear = function () {
    var attrs = this.attrs;
    var attrNames = Object.keys(attrs);
    var linearAttrs = [];
    var nonlinearAttrs = [];
    attrNames.forEach(function (attrName) {
      if (attrName === 'x' || attrName === 'y') {
        linearAttrs.push(attrName);
        return;
      }
      var scale = attrs[attrName].scale;
      if (scale && scale.type === 'linear') {
        linearAttrs.push(attrName);
      } else {
        nonlinearAttrs.push(attrName);
      }
    });
    return {
      linearAttrs: linearAttrs,
      nonlinearAttrs: nonlinearAttrs
    };
  };
  return AttrController;
}();
export default AttrController;