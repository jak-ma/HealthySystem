import { __assign, __extends } from "tslib";
import { jsx, Component } from '@antv/f-engine';
import { partition, hierarchy } from '../../deps/d3-hierarchy/src';
import { Category } from '../../attr';
import CoordController from '../../controller/coord';
import { mix, isFunction } from '@antv/util';
import Theme from '../../theme';
function rootParent(data) {
  var d = data;
  while (d.depth > 1) {
    d = d.parent;
  }
  return d;
}
export default (function (View) {
  return /** @class */function (_super) {
    __extends(Sunburst, _super);
    function Sunburst(props, context) {
      var _this = _super.call(this, props, context) || this;
      var color = props.color,
        data = props.data;
      _this.coord = new CoordController();
      _this.color = new Category(__assign(__assign({
        range: Theme.colors
      }, color), {
        data: data
      }));
      return _this;
    }
    Sunburst.prototype.willMount = function () {
      var _a = this,
        props = _a.props,
        coord = _a.coord,
        layout = _a.layout;
      var coordOption = props.coord;
      coord.updateLayout(layout);
      coord.create(coordOption);
    };
    Sunburst.prototype.didMount = function () {};
    Sunburst.prototype._mapping = function (children) {
      var _a = this,
        colorAttr = _a.color,
        coord = _a.coord;
      for (var i = 0, len = children.length; i < len; i++) {
        var node = children[i];
        var root = rootParent(node);
        var color = colorAttr.mapping(root.data[colorAttr.field]);
        node.color = color;
        var x0 = node.x0,
          x1 = node.x1,
          y0 = node.y0,
          y1 = node.y1;
        var rect = coord.getCoord().convertRect({
          x: [x0, x1],
          y: [y0, y1]
        });
        mix(node, rect);
        // 递归处理
        if (node.children && node.children.length) {
          this._mapping(node.children);
        }
      }
    };
    Sunburst.prototype.sunburst = function () {
      var props = this.props;
      var data = props.data,
        value = props.value,
        _a = props.sort,
        sort = _a === void 0 ? true : _a;
      var root = hierarchy({
        children: data
      }).sum(function (d) {
        return d[value];
      });
      // 内置按value大小顺序排序，支持传入sort函数
      if (sort === true || isFunction(sort)) {
        var sortFn = isFunction(sort) ? sort : function (a, b) {
          return b[value] - a[value];
        };
        root.sort(sortFn);
      }
      var nodes = partition()(root);
      var children = nodes.children;
      this._mapping(children);
      return nodes;
    };
    Sunburst.prototype.render = function () {
      var node = this.sunburst();
      var _a = this,
        coord = _a.coord,
        props = _a.props;
      return jsx(View, __assign({}, props, {
        coord: coord.getCoord(),
        node: node,
        triggerRef: this.triggerRef
      }));
    };
    return Sunburst;
  }(Component);
});