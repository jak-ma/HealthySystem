import { getTickMethod } from '../../deps/f2-scale/src';
import { getRange, isArray } from '@antv/util';
import { toTimeStamp } from '../../util';
// 判断新老values是否相等，这里只要判断前后是否相等即可
function isValuesEqual(values, newValues) {
  if (values.length !== newValues.length) {
    return false;
  }
  var lastIndex = values.length - 1;
  return values[0] === newValues[0] && values[lastIndex] === newValues[lastIndex];
}
function updateCategoryRange(scale, originScale, range) {
  var currentValues = scale.values,
    currentTicks = scale.ticks,
    tickMethod = scale.tickMethod,
    tickCount = scale.tickCount;
  var originValues = originScale.values;
  var start = range[0],
    end = range[1];
  var len = originValues.length;
  var valueStart = start * len;
  var valueEnd = end * len;
  // 保持滑动时个数的稳定
  var diff = valueEnd - valueStart;
  var precision = parseFloat(diff.toFixed(3)); // js 计算精度问题
  var count = Math.round(precision);
  var sliceSatrt = Math.min(Math.round(valueStart), len - count);
  // 从原始数据里截取需要显示的数据
  var newValues = originValues.slice(sliceSatrt, sliceSatrt + count);
  // 根据当前数据的比例，和定义的tickCount计算应该需要多少个ticks
  var newTickCount = Math.round(tickCount * originValues.length / newValues.length);
  // 计算新的ticks
  var catTicks = getTickMethod(tickMethod);
  var newTicks = catTicks({
    tickCount: newTickCount,
    values: originValues
  });
  // 如果新数组和当前显示的数组相同，则不更新
  if (isValuesEqual(currentValues, newValues) && isValuesEqual(currentTicks, newTicks)) {
    return;
  }
  scale.change({
    values: newValues,
    ticks: newTicks
  });
  return scale;
}
function updateLinearRange(scale, originScale, range) {
  var min = originScale.min,
    max = originScale.max;
  var start = range[0],
    end = range[1];
  var newMin = min + (max - min) * start;
  var newMax = min + (max - min) * end;
  scale.change({
    min: newMin,
    max: newMax,
    nice: false
  });
}
function updateScale(scale, values) {
  var isLinear = scale.isLinear;
  if (isLinear) {
    var _a = getRange(values),
      min = _a.min,
      max = _a.max;
    return scale.change({
      min: min,
      max: max,
      nice: true
    });
  }
}
function updateRange(scale, originScale, range) {
  var isCategory = scale.isCategory,
    isLinear = scale.isLinear;
  if (isCategory) {
    return updateCategoryRange(scale, originScale, range);
  }
  if (isLinear) {
    return updateLinearRange(scale, originScale, range);
  }
}
function updateFollow(scales, mainScale, data) {
  var mainField = mainScale.field,
    mainType = mainScale.type,
    mainValues = mainScale.values;
  // 转成 map 提高查询性能
  var mainValuesMap = {};
  mainValues.forEach(function (item) {
    mainValuesMap[item] = true;
  });
  return scales.map(function (scale) {
    var followField = scale.field;
    var values = [];
    data.forEach(function (item) {
      var value = mainType === 'timeCat' ? toTimeStamp(item[mainField]) : item[mainField];
      if (mainValuesMap[value]) {
        var followItemValue = item[followField];
        if (isArray(followItemValue)) {
          values.push.apply(values, followItemValue);
        } else {
          values.push(followItemValue);
        }
      }
    });
    return updateScale(scale, values);
  });
}
export { updateRange, updateFollow };