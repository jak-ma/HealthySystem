"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = require("tslib");
var _fEngine = require("@antv/f-engine");
var getPoint = function getPoint(cener, angle, r) {
  var x = cener.x + Math.cos(angle) * r;
  var y = cener.y + Math.sin(angle) * r;
  return {
    x: x,
    y: y
  };
};
var getTicks = function getTicks(start, end, tickCount, center, r, tickOffset, tickLength) {
  var ticks = [];
  var diff = end - start;
  for (var i = 0; i <= tickCount; i++) {
    var tickValue = start + diff * i / tickCount;
    var startPoint = getPoint(center, tickValue, r + tickOffset - tickLength);
    var endPoint = getPoint(center, tickValue, r + tickOffset);
    ticks.push({
      tickValue: tickValue,
      start: startPoint,
      end: endPoint
    });
  }
  return ticks;
};
var withGauge = function withGauge(View) {
  return /** @class */function (_super) {
    (0, _tslib.__extends)(Gauge, _super);
    function Gauge() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Gauge.prototype.render = function () {
      var _a = this,
        props = _a.props,
        context = _a.context;
      var startAngle = props.startAngle,
        endAngle = props.endAngle,
        tickCount = props.tickCount,
        center = props.center,
        r = props.r,
        tickOffset = props.tickOffset,
        tickLength = props.tickLength;
      var ticks = getTicks(startAngle, endAngle, tickCount, center, context.px2hd(r), context.px2hd(tickOffset), context.px2hd(tickLength));
      return (0, _fEngine.jsx)(View, (0, _tslib.__assign)({}, props, {
        ticks: ticks
      }));
    };
    return Gauge;
  }(_fEngine.Component);
};
var _default = exports.default = withGauge;