"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = require("tslib");
var _fEngine = require("@antv/f-engine");
var _util = require("@antv/util");
var _geometry = _interopRequireDefault(require("../geometry"));
var _default = exports.default = function _default(View) {
  return /** @class */function (_super) {
    (0, _tslib.__extends)(Line, _super);
    function Line() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Line.prototype.getDefaultCfg = function () {
      return {
        geomType: 'line',
        sortable: true
      };
    };
    Line.prototype.splitPoints = function (points) {
      var topPoints = [];
      var bottomPoints = [];
      for (var i = 0, len = points.length; i < len; i++) {
        var point = points[i];
        var x = point.x,
          y = point.y;
        topPoints.push((0, _tslib.__assign)((0, _tslib.__assign)({}, point), {
          x: x,
          y: y[1]
        }));
        bottomPoints.push((0, _tslib.__assign)((0, _tslib.__assign)({}, point), {
          x: x,
          y: y[0]
        }));
      }
      return [topPoints, bottomPoints];
    };
    Line.prototype.splitNulls = function (points, connectNulls) {
      if (connectNulls) {
        var tmpPoints_1 = [];
        for (var i = 0, len = points.length; i < len; i++) {
          var point = points[i];
          var x = point.x,
            y = point.y;
          // 过滤 x 为 NaN 的点
          if (isNaN(x)) {
            continue;
          }
          if ((0, _util.isArray)(y)) {
            if (isNaN(y[0])) {
              continue;
            }
            tmpPoints_1.push(point);
            continue;
          }
          if (isNaN(y)) {
            continue;
          }
          tmpPoints_1.push(point);
        }
        if (tmpPoints_1.length) {
          return [tmpPoints_1];
        }
        return [];
      }
      var result = [];
      var tmpPoints = [];
      for (var i = 0, len = points.length; i < len; i++) {
        var point = points[i];
        var x = point.x,
          y = point.y;
        // 过滤 x 为 NaN 的点
        if (isNaN(x)) {
          continue;
        }
        if ((0, _util.isArray)(y)) {
          if (isNaN(y[0])) {
            if (tmpPoints.length) {
              result.push(tmpPoints);
              tmpPoints = [];
            }
            continue;
          }
          tmpPoints.push(point);
          continue;
        }
        if (isNaN(y)) {
          if (tmpPoints.length) {
            result.push(tmpPoints);
            tmpPoints = [];
          }
          continue;
        }
        tmpPoints.push(point);
      }
      if (tmpPoints.length) {
        result.push(tmpPoints);
      }
      return result;
    };
    Line.prototype.mapping = function () {
      var _this = this;
      var records = _super.prototype.mapping.call(this);
      var _a = this,
        props = _a.props,
        defaultConnectNulls = _a.connectNulls,
        context = _a.context;
      var coord = props.coord,
        _b = props.connectNulls,
        connectNulls = _b === void 0 ? defaultConnectNulls : _b,
        sizeZoom = props.sizeZoom;
      return records.map(function (record) {
        var _a;
        var children = record.children;
        // children 有可能为空
        var _b = children[0] || {},
          size = _b.size,
          color = _b.color,
          shape = _b.shape,
          y = _b.y,
          origin = _b.origin;
        // 极坐标时，需加入起点，从而闭合所绘图形
        var points = coord.isPolar ? (0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], children, true), [children[0]], false) : children;
        var sizeZoomRatio = (_a = (0, _util.isFunction)(sizeZoom) ? sizeZoom(origin) : sizeZoom) !== null && _a !== void 0 ? _a : 1;
        var splitPoints = _this.splitNulls(points, connectNulls);
        var newChildren = splitPoints.map(function (points) {
          var _a = (0, _util.isArray)(y) ? _this.splitPoints(points) : [points, undefined],
            topPoints = _a[0],
            bottomPoints = _a[1];
          return {
            size: context.px2hd(size || shape.lineWidth) * sizeZoomRatio,
            color: color,
            shape: shape,
            points: [].concat(topPoints),
            topPoints: topPoints,
            bottomPoints: bottomPoints
          };
        });
        return (0, _tslib.__assign)((0, _tslib.__assign)({}, record), {
          children: newChildren
        });
      });
    };
    Line.prototype.concatPoints = function (topPoints, bottomPoints) {
      if (!bottomPoints || !bottomPoints.length) {
        return topPoints;
      }
      var adjust = this.adjust;
      // 堆叠产生的 bottomPoints 不绘制
      if (adjust && adjust.type === 'stack') {
        return topPoints;
      }
      // 说明是 y 轴对应字段为数组， 这种情况下首尾默认相连，如果想画 2 根线，在数据里对数组分拆
      var points = topPoints.concat(bottomPoints.reverse());
      points.push(topPoints[0]);
      return points;
    };
    Line.prototype.render = function () {
      var props = this.props;
      var coord = props.coord;
      var records = this.mapping();
      var clip = this.getClip();
      for (var i = 0, len = records.length; i < len; i++) {
        var record = records[i];
        var children = record.children;
        for (var j = 0, len_1 = children.length; j < len_1; j++) {
          var child = children[j];
          var points = child.points,
            bottomPoints = child.bottomPoints;
          child.points = this.concatPoints(points, bottomPoints);
        }
      }
      return (0, _fEngine.jsx)(View, (0, _tslib.__assign)({}, props, {
        coord: coord,
        records: records,
        clip: clip
      }));
    };
    return Line;
  }(_geometry.default);
};