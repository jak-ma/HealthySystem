"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = require("tslib");
var _fEngine = require("@antv/f-engine");
var _src = require("../../deps/d3-hierarchy/src");
var _attr = require("../../attr");
var _coord = _interopRequireDefault(require("../../controller/coord"));
var _util = require("@antv/util");
var _theme = _interopRequireDefault(require("../../theme"));
function rootParent(data) {
  var d = data;
  while (d.depth > 1) {
    d = d.parent;
  }
  return d;
}
var _default = exports.default = function _default(View) {
  return /** @class */function (_super) {
    (0, _tslib.__extends)(Sunburst, _super);
    function Sunburst(props, context) {
      var _this = _super.call(this, props, context) || this;
      var color = props.color,
        data = props.data;
      _this.coord = new _coord.default();
      _this.color = new _attr.Category((0, _tslib.__assign)((0, _tslib.__assign)({
        range: _theme.default.colors
      }, color), {
        data: data
      }));
      return _this;
    }
    Sunburst.prototype.willMount = function () {
      var _a = this,
        props = _a.props,
        coord = _a.coord,
        layout = _a.layout;
      var coordOption = props.coord;
      coord.updateLayout(layout);
      coord.create(coordOption);
    };
    Sunburst.prototype.didMount = function () {};
    Sunburst.prototype._mapping = function (children) {
      var _a = this,
        colorAttr = _a.color,
        coord = _a.coord;
      for (var i = 0, len = children.length; i < len; i++) {
        var node = children[i];
        var root = rootParent(node);
        var color = colorAttr.mapping(root.data[colorAttr.field]);
        node.color = color;
        var x0 = node.x0,
          x1 = node.x1,
          y0 = node.y0,
          y1 = node.y1;
        var rect = coord.getCoord().convertRect({
          x: [x0, x1],
          y: [y0, y1]
        });
        (0, _util.mix)(node, rect);
        // 递归处理
        if (node.children && node.children.length) {
          this._mapping(node.children);
        }
      }
    };
    Sunburst.prototype.sunburst = function () {
      var props = this.props;
      var data = props.data,
        value = props.value,
        _a = props.sort,
        sort = _a === void 0 ? true : _a;
      var root = (0, _src.hierarchy)({
        children: data
      }).sum(function (d) {
        return d[value];
      });
      // 内置按value大小顺序排序，支持传入sort函数
      if (sort === true || (0, _util.isFunction)(sort)) {
        var sortFn = (0, _util.isFunction)(sort) ? sort : function (a, b) {
          return b[value] - a[value];
        };
        root.sort(sortFn);
      }
      var nodes = (0, _src.partition)()(root);
      var children = nodes.children;
      this._mapping(children);
      return nodes;
    };
    Sunburst.prototype.render = function () {
      var node = this.sunburst();
      var _a = this,
        coord = _a.coord,
        props = _a.props;
      return (0, _fEngine.jsx)(View, (0, _tslib.__assign)({}, props, {
        coord: coord.getCoord(),
        node: node,
        triggerRef: this.triggerRef
      }));
    };
    return Sunburst;
  }(_fEngine.Component);
};