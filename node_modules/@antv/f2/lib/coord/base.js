"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _util = require("@antv/util");
function transposedRect(_a) {
  var xMin = _a.xMin,
    xMax = _a.xMax,
    yMin = _a.yMin,
    yMax = _a.yMax;
  return {
    xMin: yMin,
    xMax: yMax,
    yMin: xMin,
    yMax: xMax
  };
}
function convertRect(_a) {
  var x = _a.x,
    y = _a.y,
    size = _a.size,
    y0 = _a.y0;
  var xMin;
  var xMax;
  if ((0, _util.isArray)(x)) {
    xMin = x[0];
    xMax = x[1];
  } else {
    xMin = x - size / 2;
    xMax = x + size / 2;
  }
  var yMin;
  var yMax;
  if ((0, _util.isArray)(y)) {
    if (y[0] === y[1]) {
      yMin = y[0];
      yMax = y[1];
    } else {
      yMin = Math.min(y[0], y[1]);
      yMax = Math.max(y[0], y[1]);
    }
  } else {
    yMin = Math.min(y0, y);
    yMax = Math.max(y0, y);
  }
  return {
    xMin: xMin,
    xMax: xMax,
    yMin: yMin,
    yMax: yMax
  };
}
/**
 * 直角坐标系
 * convert相关的方法，涉及将标准坐标系映射到实际坐标系内
 * transform相关的方法，是仅将某一种关键点转换成另一种关键点 (比如将x/y/size/y0转换成yMin/yMax/..)
 */
var Base = /** @class */function () {
  function Base(option) {
    this.left = 0;
    this.top = 0;
    this.width = 0;
    this.height = 0;
    // x y 调换
    this.transposed = false;
    // x，y 的值域，在极坐标中对应的就是弧度和半径
    this.x = [0, 1];
    this.y = [0, 1];
    this.update(option);
  }
  Base.prototype.update = function (option) {
    (0, _util.mix)(this, option);
    var _a = this,
      left = _a.left,
      top = _a.top,
      width = _a.width,
      height = _a.height;
    this.right = left + width;
    this.bottom = top + height;
    this.center = {
      x: left + width / 2,
      y: top + height / 2
    };
    return this;
  };
  // 是循环， 比如极坐标是以 2π 循环的
  Base.prototype.isCyclic = function () {
    return false;
  };
  Base.prototype._zoomVal = function (val, func) {
    return (0, _util.isArray)(val) ? val.map(function (v) {
      return func(v);
    }) : func(val);
  };
  /**
   * 把归一后的值映射到对应的定义域
   * @param point
   */
  Base.prototype.convert = function (point) {
    var _a = this,
      transposed = _a.transposed,
      x = _a.x,
      y = _a.y;
    var xDim = transposed ? 'y' : 'x';
    var yDim = transposed ? 'x' : 'y';
    var pointX = point[xDim];
    var pointY = point[yDim];
    // 超出边界不绘制
    if (pointX < 0 || pointX > 1 || pointY < 0 || pointY > 1) {
      return {
        x: NaN,
        y: NaN
      };
    }
    return {
      x: this._zoomVal(point[xDim], function (v) {
        return x[0] + (x[1] - x[0]) * v;
      }),
      y: this._zoomVal(point[yDim], function (v) {
        return y[0] + (y[1] - y[0]) * v;
      })
    };
  };
  /**
   * convert 的反处理，把定义域的值，反处理到归一的值
   */
  Base.prototype.invert = function (point) {
    var _a;
    var _b = this,
      transposed = _b.transposed,
      x = _b.x,
      y = _b.y;
    var xDim = transposed ? 'y' : 'x';
    var yDim = transposed ? 'x' : 'y';
    return _a = {}, _a[xDim] = this._zoomVal(point.x, function (v) {
      return (v - x[0]) / (x[1] - x[0]);
    }), _a[yDim] = this._zoomVal(point.y, function (v) {
      return (v - y[0]) / (y[1] - y[0]);
    }), _a;
  };
  /**
   * 把归一化的值映射到 canvas 的坐标点
   * @param point
   * @returns
   */
  Base.prototype.convertPoint = function (point) {
    return this.convert(point);
  };
  /**
   * 把canvas坐标的点位映射回归一的值
   */
  Base.prototype.invertPoint = function (point) {
    return this.invert(point);
  };
  // 将标准坐标系下的矩形绘制关键点映射成实际绘制的坐标点
  Base.prototype.convertRect = function (rectPoint) {
    var _a = this,
      xRange = _a.x,
      yRange = _a.y,
      transposed = _a.transposed;
    var xStart = xRange[0],
      xEnd = xRange[1];
    var yStart = yRange[0],
      yEnd = yRange[1];
    var rect = convertRect(rectPoint);
    var _b = transposed ? transposedRect(rect) : rect,
      xMin = _b.xMin,
      xMax = _b.xMax,
      yMin = _b.yMin,
      yMax = _b.yMax;
    var x0 = xStart + (xEnd - xStart) * xMin;
    var x1 = xStart + (xEnd - xStart) * xMax;
    var y0 = yStart + (yEnd - yStart) * yMin;
    var y1 = yStart + (yEnd - yStart) * yMax;
    return {
      xMin: Math.min(x0, x1),
      xMax: Math.max(x0, x1),
      yMin: Math.min(y0, y1),
      yMax: Math.max(y0, y1)
    };
  };
  // 将已经映射好的矩形绘制关键点转换成实际绘制的坐标点
  Base.prototype.transformToRect = function (rectPoint) {
    var x = rectPoint.x,
      y = rectPoint.y,
      y0 = rectPoint.y0,
      size = rectPoint.size;
    var coordOrigin = this.convertPoint({
      x: 0,
      y: y0
    });
    var transposed = this.transposed;
    var _rectPoint = {
      size: size,
      x: transposed ? y : x,
      y: transposed ? x : y,
      y0: transposed ? coordOrigin.x : coordOrigin.y
    };
    var rect = convertRect(_rectPoint);
    var _a = transposed ? transposedRect(rect) : rect,
      xMin = _a.xMin,
      xMax = _a.xMax,
      yMin = _a.yMin,
      yMax = _a.yMax;
    return {
      xMin: xMin,
      xMax: xMax,
      yMin: yMin,
      yMax: yMax
    };
  };
  return Base;
}();
var _default = exports.default = Base;