"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ATTRS = void 0;
var _tslib = require("tslib");
var _util = require("@antv/util");
var Attrs = _interopRequireWildcard(require("../attr"));
var _fEngine = require("@antv/f-engine");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
var Identity = Attrs.Identity,
  Linear = Attrs.Linear,
  Category = Attrs.Category;
// 需要映射的属性名
var ATTRS = exports.ATTRS = ['x', 'y', 'color', 'size', 'shape'];
// 分组处理的属性
var GROUP_ATTRS = ['color', 'size', 'shape'];
function cloneScale(scale, scaleConfig) {
  // @ts-ignore
  return new scale.constructor((0, _tslib.__assign)((0, _tslib.__assign)({}, scale.__cfg__), scaleConfig));
}
var AttrController = /** @class */function () {
  function AttrController(scaleController, attrsRange) {
    this.scaleController = scaleController;
    this.attrsRange = attrsRange;
    this.options = {};
    this.attrs = {};
  }
  AttrController.prototype.parseOption = function (option, attrName) {
    if (!option) {
      return {
        type: 'identity'
      };
    }
    if ((0, _util.isString)(option)) {
      return {
        field: option,
        type: 'category'
      };
    }
    if ((0, _util.isNumber)(option)) {
      if (attrName === 'size') {
        return {
          type: 'identity',
          field: option
        };
      }
    }
    if ((0, _util.isArray)(option)) {
      return {
        field: option[0],
        range: option[1]
      };
    }
    return option;
  };
  AttrController.prototype.getAttrOptions = function (props, justifyContentCenter) {
    var _this = this;
    if (!props.x || !props.y) {
      throw new Error('x, y are required !');
    }
    var options = {};
    var ranges = this.attrsRange;
    ATTRS.forEach(function (attrName) {
      if (!props[attrName]) return;
      var option = _this.parseOption(props[attrName], attrName);
      if (!option.range) {
        option.range = ranges[attrName];
      }
      options[attrName] = option;
    });
    // @ts-ignore
    var x = options.x,
      y = options.y;
    x.justifyContent = justifyContentCenter;
    // x, y 都是固定Linear 映射
    x.type = Linear;
    y.type = Linear;
    return options;
  };
  AttrController.prototype.getDefaultAttrValues = function () {
    var _a = this.attrsRange,
      color = _a.color,
      shape = _a.shape;
    return {
      color: color[0],
      shape: shape && shape[0]
    };
  };
  AttrController.prototype.getGroupScales = function () {
    var attrs = this.attrs;
    var scales = [];
    (0, _util.each)(GROUP_ATTRS, function (attrName) {
      var attr = attrs[attrName];
      if (!attr) {
        return;
      }
      var scale = attr.scale;
      if (scale && scale.isCategory && scales.indexOf(scale) === -1) {
        scales.push(scale);
      }
    });
    return scales;
  };
  AttrController.prototype.createAttr = function (option) {
    var type = option.type,
      field = option.field,
      scaleConfig = option.scale;
    if ((0, _util.isNil)(field) || type === Identity) {
      return new Identity(option);
    }
    var scale = this.scaleController.getScale(field);
    var attrOption = (0, _tslib.__assign)((0, _tslib.__assign)({}, option), {
      data: this.scaleController.getData(),
      // scaleConfig 只在属性映射中生效
      scale: scaleConfig ? cloneScale(scale, scaleConfig) : scale
    });
    // identity
    if (scale && scale.type === 'identity') {
      return new Identity(attrOption);
    }
    // Attr的默认类型和scale类型保持一致
    var AttrConstructor = scale.isLinear ? Linear : Category;
    // custom Attr Constructor
    if ((0, _util.isFunction)(type)) {
      AttrConstructor = type;
    }
    if ((0, _util.isString)(type) && Attrs[(0, _util.upperFirst)(type)]) {
      AttrConstructor = Attrs[(0, _util.upperFirst)(type)];
    }
    return new AttrConstructor(attrOption);
  };
  AttrController.prototype.create = function (options) {
    this.update(options);
  };
  AttrController.prototype.update = function (nextOptions) {
    var _a = this,
      scaleController = _a.scaleController,
      lastOptions = _a.options,
      lastAttrs = _a.attrs;
    var nextAttrs = {};
    (0, _util.each)(nextOptions, function (nextOption, attrName) {
      var lastOption = lastOptions[attrName];
      if ((0, _fEngine.isEqual)(nextOption, lastOption)) {
        nextAttrs[attrName] = lastAttrs[attrName];
      }
      var field = nextOption.field,
        justifyContent = nextOption.justifyContent;
      if (field) {
        scaleController.setScale(field, {
          justifyContent: justifyContent
        });
      }
    });
    this.options = nextOptions;
    this.attrs = nextAttrs;
  };
  AttrController.prototype.getAttr = function (attrName) {
    var _a = this,
      attrs = _a.attrs,
      options = _a.options;
    var attr = attrs[attrName];
    if (attr) {
      return attr;
    }
    var option = options[attrName];
    if (!option) {
      return null;
    }
    var newAttr = this.createAttr(option);
    attrs[attrName] = newAttr;
    return newAttr;
  };
  AttrController.prototype.getAttrs = function () {
    var _this = this;
    var _a = this,
      options = _a.options,
      attrs = _a.attrs;
    (0, _util.each)(options, function (option, attrName) {
      _this.getAttr(attrName);
    });
    return attrs;
  };
  AttrController.prototype.isGroupAttr = function (attrName) {
    return GROUP_ATTRS.indexOf(attrName) !== -1;
  };
  AttrController.prototype.getAttrsByLinear = function () {
    var attrs = this.attrs;
    var attrNames = Object.keys(attrs);
    var linearAttrs = [];
    var nonlinearAttrs = [];
    attrNames.forEach(function (attrName) {
      if (attrName === 'x' || attrName === 'y') {
        linearAttrs.push(attrName);
        return;
      }
      var scale = attrs[attrName].scale;
      if (scale && scale.type === 'linear') {
        linearAttrs.push(attrName);
      } else {
        nonlinearAttrs.push(attrName);
      }
    });
    return {
      linearAttrs: linearAttrs,
      nonlinearAttrs: nonlinearAttrs
    };
  };
  return AttrController;
}();
var _default = exports.default = AttrController;