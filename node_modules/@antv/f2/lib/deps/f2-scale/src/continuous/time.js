"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _tslib = require("tslib");
var _util = require("@antv/util");
var _time = require("../util/time");
var _linear = _interopRequireDefault(require("./linear"));
/**
 * 时间度量
 * @class
 */
var Time = /** @class */function (_super) {
  (0, _tslib.__extends)(Time, _super);
  function Time() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = 'time';
    return _this;
  }
  /**
   * @override
   */
  Time.prototype.getText = function (value, index) {
    var numberValue = this.translate(value);
    var formatter = this.formatter;
    return formatter ? formatter(numberValue, index) : (0, _time.timeFormat)(numberValue, this.mask);
  };
  /**
   * @override
   */
  Time.prototype.scale = function (value) {
    var v = value;
    if ((0, _util.isString)(v) || (0, _util.isDate)(v)) {
      v = this.translate(v);
    }
    return _super.prototype.scale.call(this, v);
  };
  /**
   * 将时间转换成数字
   * @override
   */
  Time.prototype.translate = function (v) {
    return (0, _time.toTimeStamp)(v);
  };
  Time.prototype.initCfg = function () {
    this.tickMethod = 'time-pretty';
    this.mask = 'YYYY-MM-DD';
    this.tickCount = 7;
    this.nice = false;
  };
  Time.prototype.setDomain = function () {
    var values = this.values;
    // 是否设置了 min, max，而不是直接取 this.min, this.max
    var minConfig = this.getConfig('min');
    var maxConfig = this.getConfig('max');
    // 如果设置了 min,max 则转换成时间戳
    if (!(0, _util.isNil)(minConfig) || !(0, _util.isNumber)(minConfig)) {
      this.min = this.translate(this.min);
    }
    if (!(0, _util.isNil)(maxConfig) || !(0, _util.isNumber)(maxConfig)) {
      this.max = this.translate(this.max);
    }
    // 没有设置 min, max 时
    if (values && values.length) {
      // 重新计算最大最小值
      var timeStamps_1 = [];
      var min_1 = Infinity; // 最小值
      var secondMin_1 = min_1; // 次小值
      var max_1 = 0;
      // 使用一个循环，计算min,max,secondMin
      (0, _util.each)(values, function (v) {
        var timeStamp = (0, _time.toTimeStamp)(v);
        if (isNaN(timeStamp)) {
          throw new TypeError("Invalid Time: ".concat(v, " in time scale!"));
        }
        if (min_1 > timeStamp) {
          secondMin_1 = min_1;
          min_1 = timeStamp;
        } else if (secondMin_1 > timeStamp) {
          secondMin_1 = timeStamp;
        }
        if (max_1 < timeStamp) {
          max_1 = timeStamp;
        }
        timeStamps_1.push(timeStamp);
      });
      // 存在多个值时，设置最小间距
      if (values.length > 1) {
        this.minTickInterval = secondMin_1 - min_1;
      }
      if ((0, _util.isNil)(minConfig)) {
        this.min = min_1;
      }
      if ((0, _util.isNil)(maxConfig)) {
        this.max = max_1;
      }
    }
  };
  return Time;
}(_linear.default);
var _default = exports.default = Time;